% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/colwise.R
\name{summarise_all}
\alias{mutate_all}
\alias{mutate_at}
\alias{mutate_each_q}
\alias{mutate_if}
\alias{summarise_all}
\alias{summarise_at}
\alias{summarise_each_q}
\alias{summarise_if}
\title{Summarise and mutate multiple columns.}
\usage{
summarise_all(.tbl, .funs, ...)

mutate_all(.tbl, .funs, ...)

summarise_if(.tbl, .predicate, .funs, ...)

mutate_if(.tbl, .predicate, .funs, ...)

summarise_at(.tbl, .cols, .funs, ...)

mutate_at(.tbl, .cols, .funs, ...)
}
\arguments{
\item{.tbl}{a tbl}

\item{.funs}{List of function calls generated by
\code{\link{funs}()}, or a character vector of function names, or
simply a function (only for local sources).}

\item{...}{Additional arguments for the function calls. These are
evaluated only once.}

\item{.predicate}{A predicate function to be applied to the columns
or a logical vector. The columns for which \code{.predicate} is
or returns \code{TRUE} will be summarised or mutated.}

\item{.cols}{A list of columns generated by \code{\link{columns}()},
or a character vector of column names, or a numeric vector of column
positions.}
}
\value{
A data frame. By default, the newly created columns the shortest
  names needed to distinguish the output. To force inclusion of a name,
  even when not needed, name the input (see examples for details).
}
\description{
Apply one or more functions to one or more columns. Grouping variables
are always excluded from modification.
}
\examples{
# One function
by_species <- iris \%>\% group_by(Species)
by_species \%>\% summarise_all(length)
by_species \%>\% summarise_all(mean)

# Use the _at and _if variants for conditional mapping.
# summarise_at() can use select() helpers with the columns() function:
by_species \%>\% summarise_at(columns(Petal.Width), mean)
by_species \%>\% summarise_at(columns(matches("Width")), mean)
by_species \%>\% summarise_if(is.numeric, mean)

# You can also specify columns with column names or column positions:
by_species \%>\% summarise_at(c("Sepal.Width", "Petal.Width"), mean)
by_species \%>\% summarise_at(c(1, 3), mean)

# Or with logical vectors:
by_species \%>\% summarise_if(c(TRUE, TRUE, FALSE, TRUE, FALSE), mean)

# You can provide additional arguments. Those are evaluated only once:
by_species \%>\% summarise_all(mean, trim = 1)
by_species \%>\% summarise_at(columns(Petal.Width), mean, trim = 1)


# Instead of functions, you can provide expressions with the funs() helper:
by_species \%>\% mutate_all(funs(half = . / 2))
by_species \%>\% mutate_all(funs(min_rank))

# Two functions
by_species \%>\% summarise_all(funs(min, max))
by_species \%>\% summarise_at(columns(Petal.Width, Sepal.Width), funs(min, max))
by_species \%>\% summarise_at(columns(matches("Width")), funs(min, max))

# By default the names are minimal. Name the inputs to make them
# explicit
by_species \%>\% summarise_all(funs(min))
by_species \%>\% summarise_all(funs(min = min))
by_species \%>\% summarise_at(columns(Sepal.Length), funs(min, max))
by_species \%>\% summarise_at(columns(Sepal.Length = Sepal.Length), funs(min, max))

# Alternative function specification
iris \%>\% summarise_all(funs(ul = length(unique(.))))
by_species \%>\% summarise_all(funs(ul = length(unique(.))))

by_species \%>\% summarise_all(c("min", "max"))

}
\seealso{
\code{\link{columns}()}, \code{\link{funs}()}
}

